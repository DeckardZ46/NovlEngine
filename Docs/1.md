# 游戏制作的窄门：构建mini游戏引擎 - 1 - Third Party Libs

## 0. C++项目中的第三方库
本系列的项目是一个C++项目，不幸的是C++并没有像其他很多语言一样有个很好用的包管理工具，类似Java的Maven或者Python的Anaconda之类，所以我们需要稍微麻烦一点来把第三方库集成进项目里  
- 可以把第三方库的源码放进项目，作为依赖的子项目一起构建，举例在本系列中即`Libs/{LibName}/src`中放进源码，然后另外写一个xmake.lua来构建这个子项目，然后在我们主项目的xmake.lua中添加这个子项目的依赖即可
- 也可以直接把第三方库构建成动态/静态库文件（在Windows下就是.dll和.lib文件），然后直接在项目中link即可，在本系列中会在`Libs/{LibName}/bin`中放入第三方库文件  
直接把构建好的库文件放进项目里用的缺点就是针对每个平台和架构都得放一套binary文件，但是每次构建会快一点，且文件结构也更清晰一些，不会有文件太多看着很乱的感觉，本系列大部分第三方库文件选用这样的结构来集成第三方库  
在xmake.lua中，我们把这些库link到主项目上
```lua
-- static
libs = {"LibNames"}

for _,lib in ipairs(libs) do
    add_includedirs(string.format("../Libs/%s/include",lib))
    add_linkdirs(string.format("../Libs/%s/bin/$(plat)/$(arch)"),lib)
    add_links(lib)
end

-- shared
libs = {"LibNames"}

for _,lib in ipairs(libs) do
    add_includedirs(string.format("../Libs/%s/include",lib))
    add_linkdirs(string.format("../Libs/%s/bin/$(plat)/$(arch)"),lib)
    add_links(string.format("%sdll",lib))
end
```

## 1. 图形API
图形渲染是游戏引擎最重要的部分之一，在这一篇中我们首先来构建图形渲染的环境依赖
在图形渲染中有多种图形API可用，经典的OpenGL/DX9，以及更modern一点的metal/vulkan/dx11/dx12，包括Console上也有自己的图形API比如PS4上的GNM、Switch上的NVN等  
在本系列的开端，博主倾向于从最basic的东西做起，所以来到我们熟悉的OpenGL   
***当然，想要构建一个modern游戏引擎而不是一个古早技术玩具，需要使用现代一些的图形API，本系列在后面图形渲染部分计划加上vulkan & metal的backend支持，但是我们先从用OpenGL作为backend开始*** 

### OpenGL的libs
在学习OpenGL的过程中，可能会接触到多种OpenGL的库，比如glut/glew/glad/glfw，具体的区别一搜就有，结论就是glut是很古早的库了，基本可以进博物馆，glew基本是包含了OpenGL的core内容，但是也比较古早了，稍微新一点的（当然也不会太新，新的都去搞vulkan了）是glfw和glad，一般做OpenGL是用这两个库，glfw是给了一个跨平台的窗口和一些类似鼠标事件、键盘事件一类东西，glad基本上是一个glew的升级版  
下面开始把`glad`和`glfw`集成进项目

### glad
glad的获取非常舒适，在[这个网站](https://glad.dav1d.de/)可以选择你需要的OpenGL的版本、需要的扩展等  
选完之后生成的glad.h中会注释选择的信息
```
Language/Generator: C/C++
Specification: gl
APIs: gl=4.6, gles2=3.2
Profile: core
Extensions:
```
此处会生成glad.h和khrplatform.h，以及glad.c，注意如果在网站中生成的时候勾选上了`Omit KHR`选项，即不生成khrplatform.h这个文件，后面编译的时候会报错，这个在没那么古老的版本都会出现，只能保留khrplatform.h文件  

然后可以写个简单的xmake脚本来把glad构建成静态库使用：
```lua
target("glad")
    set_kind("static")
    add_includedirs("include")
    add_files("**.cpp")
target_end()
```

### glfw
glfw可以直接在[GitHub](https://github.com/glfw/glfw)上获得源码，也可以直接下载到编译好的文件，博主采用的方式是编译源码  
先用CMake生成一个VS项目：`cmake -S path/to/glfw -B path/to/build`，如果想把glfw作为动态库使用，需要加上`-DBUILD_SHARED_LIBS=ON`的tag  
然后用VS打开生成的.sln,生成glfw项目 

>注意此时可能会有个小坑，我们首先要确定这个项目在Windows下的runtime是`\MD`，并且其他的库在编译的时候同样使用MD作为runtime，不然把库放进主项目link的时候会有报错  

然后我们就可以得到glfw的.lib文件，把它和include一起放进引擎项目即可  
在此时尝试xmake构建一下放入了glad和glfw的项目，结果发现还是会报错
```
无法解析的外部符号 __imp_TranslateMessage，函数 _glfwInitWin32 中引用了该符号
```
通过搜索TranslateMessage，发现这是Windows的User32库里的，我们在项目中没有link，以此类推，得到我们在Windows平台下需要的所有系统库，link进项目中
```lua
-- platform related
if is_plat("windows") then 
    add_syslinks("opengl32","user32","Gdi32","Shell32")
end 
```

## 2. UI库 - imgui
在游戏引擎的Editor中我们需要展示各种信息，以及提供各种可以交互的组件，这种功能商业引擎一般是自己写底层轮子，比如UE的Slate，但是个人开发中还是选择用现成的库比较方便，主流的选择是ImGui，它文档里说为了不混淆，最好叫全名Dear ImGui，Ok fine  
ImGui其实并不是一个性能突出的选择，UI框架也分几种，比如立即模式（immediate mode）或者保留模式（retained mode）等，ImGui的Im就是immediate mode的意思，这种模式不管有没有变动，每帧都会刷新渲染UI，并不是性能最优选择，但是好用、轻量，多平台支持友好（能画纹理图片的地方就能用ImGui！）所以本系列的Editor UI框架交给Dear ImGui  

ImGui的源码依然是在[Github](https://github.com/ocornut/imgui)上拿到，但是编译和之前不太一样，ImGui官方推荐直接把ImGui的文件放到项目文件中作为项目的一部分一起构建（也并不是作为一个子项目），但强迫症使然，博主这里把ImGui也编译成一个静态库来用  

根据ImGui的文档，我们需要源码中根目录下的文件和backends目录下的相应文件，把这些文件拿出来到`Libs/ImGui/src`中，简单构建成静态库：
```lua
target("ImGui")
    set_runtimes("MD")
    set_kind("static")
    add_includedirs("../include", "../../glfw3/include")
    add_files("**.cpp")
target_end()
```
然后把刚刚拿出来的文件其中的.h部分放进include文件夹  

在这步之后可以简单验证一下目前集成的lib的状态，我们构建一个glfw窗口和一个ImGui的demo window，仍然在之前的test.cpp中进行实验：  
```cpp
#include "pch.h"
#include "test.h"
#include <glad.h>
#include <glfw3.h>
#include <imgui.h>
#include <imgui_impl_glfw.h>
#include <imgui_impl_opengl3.h>

void framebuffer_size_callback(GLFWwindow *window, int width, int height);

void Test::test()
{
    std::cout << "hello Novl" << std::endl;

    // init glfw
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // init window
    GLFWwindow *window = glfwCreateWindow(800, 600, "Novl empty", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return;
    }
    glfwMakeContextCurrent(window);

    // init glad
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return;
    }

    glViewport(0, 0, 800, 600);

    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // imgui
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;  // Enable Gamepad Controls

    // Setup Platform/Renderer backends
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 460");

    while (!glfwWindowShouldClose(window))
    {
        glfwPollEvents();

        // (Your code process and dispatch Win32 messages)
        // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        ImGui::ShowMetricsWindow(); // Show demo window! :)

        ImGui::Render();
        glClearColor(0.0,1.0,1.0,1.0);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        glfwSwapBuffers(window);
    }

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();

    glfwTerminate();
}

void framebuffer_size_callback(GLFWwindow *window, int width, int height)
{
    glViewport(0, 0, width, height);
}
```

然后进行构建以及xmake run：  
![Test ImGui & OpenGL](pics/1/test.png)  

OK，这样ImGui和OpenGL的集成完成了  

## 3. 