# 游戏制作的窄门：构建游戏引擎 - 0 - 概述、构建工程，以及开始的一切

## -1. 自我意识的溢出
不知道最开始世界是如何被创造，如何让物质被星球吸引而坠落，如何汇聚水气倾泻大雨，光线如何从光年外孤独地穿梭来，在车窗外一粒雨滴上散射，又透过镜头被胶片或CMOS捕获；但只要想象力足够填满代码和显示器之间的缝隙，这一切都是可以魔法一样地被构建出来，在游戏引擎里。

毕业后时而陷入存在主义危机，过去宏大的、热情的、目的明确的，不知是什么时候被消磨或解构，或许是几年复杂错乱的流行病、一次紧绷疲倦的毕业招聘、或者仅仅在某场大雨的一个时刻，与世界的分离感像在日常生活中窝藏的恐怖分子一样袭击来，然后陷入巨大的空白中。

随着社会上各部分资产负债表一并剧烈收缩的是企业的野心，又随之而来的是工作上不小的变动。投入了许多精力的项目中途被停，就像正在进行战争的佣兵听到了和平的讯息那样放松下来，那样再次面对空白，之后去向是未知的，明天是复杂的漫游。停摆了一小段时间之后，对于做点什么事来产生意义的饥饿感又占据了生活，打开很久没有coding记录的Github后，还是决定把之前未完成的事情做下去。

这个简陋的引擎工程创建在英国读研的时候，当时在学校用老师自己写的一个mini engine，总感觉用起来不爽，可能是因为C++程序员莫名其妙喜欢自己造轮子的毛病，虽然我相当讨厌C++，但由于要做图形离不开它，就像生活中其他觉得恨却离不开的一切事物一样。总之，构建一个toy engine轮子的计划在重度拖延的人的手里产生了，而这个计划也确实得到了它应得的拖延。

后来真的认真去写一些代码是在临近毕业，坦诚地讲这是带有一定功利性的开发，目的是丰富简历，基本是在抄Cherno的Engine教程，后面其实也没抄完，找到了工作之后又搁置在Github角落的repo中。
好在工作其实也算是在做引擎开发，看了一些比较modern的渲染引擎实现，这个过程中总有一些零散的时刻，想要继续造自己的轮子的毛病又犯了，想把学到的三瓜两枣用到自己的垃圾引擎里面去，但苦于没有时间，且拖延，直到现在才算认真继续这个事情。拉下来仓库看看之前写的代码，几乎没有什么自己的东西，干脆推倒重来，让石头滚落下去吧，我来做一次西西弗斯。  
这次我只想认真做一个game engine，怎样也好，我只想去做就好了，直到我找到什么别的事情来产生意义吧，或者光荣地被空白打败。

博主水平有限，自认没有能力从开始就以成熟的架构构建一个高效、强大、现代的游戏引擎，所以***本系列旨在记录博主渐进构建自己的游戏引擎的学习和不断完善过程***，其中记录的知识可能会比较基础，也可能会出错，其间可能会有多次对之前文章的修订，或代码的直接重构，这一定会发生。  
现在从开始的开始开始，从我们都会做的hello world开始，重新和隐藏在虚拟世界之下永不停歇的引擎say hello。

---

## 0. 概述

游戏引擎毫无疑问是一个大型复杂软件项目，仅凭一个开发者单刀赴会一定没法做得面面俱到，所以本系列的项目并不是为了制造一个全面的、对于所有人好用的、高效的游戏引擎，主要是为了尽可能以一个现代引擎的架构，对于大部分应有的功能做浅尝辄止的实现，对于个别博主感兴趣的方向较为深入地探索，博主希望得到一个麻雀虽小，五脏俱全的轻量、简洁的游戏引擎，并且在某些方面做的还不错，这样就足够  
本系列所构建的引擎命名为Novl Engine，但这并不是一个为视觉小说或者Galgame创建的引擎！只是如果后面可以用自己的引擎做游戏的话，希望可以做出一些自己独特的叙事而已  
项目地址：https://github.com/DeckardZ46/NovlEngine  
更新速度可能会很慢，因为是用业余时间在做，但是这大概会是一个长期的项目


### 参考
最开始要做一个游戏引擎的时候其实是像无头苍蝇一样的，不知道怎样构建，不知道什么样的架构可以称之为“引擎”，可能做图形相关的人都会有一个“渲染引擎”，也许是自己搭建的，或者是Github扒的，也许是Lab里祖传的，总之是可以用来实践各类图形算法的工程。但Rendering确实只是Game Engine的其中一部分，虽然这部分非常重要，但远不是全部。我最开始得到的参考只有学校里用的mini engine，后面逐渐发现一些更有价值的参考：  

>- GAMES104 -- 非常棒的中文引擎教程，是笔者要最先推荐的资料，高密度输出现代引擎架构和较为前沿的单点技术相关知识，虽然并没有非常仔细讲每一个细节，但是已经是我能找到最好的现代引擎知识索引，教学使用的Piccolo Engine结构清晰，非常适合入门学习，感谢Booming团队的开源精神，作为开发者致敬
>- Cherno的Game Engine系列教程 -- 博主最开始就是跟着这个教程进行游戏引擎的初步探索，油管搜索即可，在b站也有搬运，非常practical的教程
>- 《游戏引擎架构》 -- Milo翻译的著作，虽然知识是有些过时，但仍然能从中学到很多东西
>- Filament -- Google开发的跨平台PBR渲染器，在移动端上表现不错，体量稍大，源码读起来有些地方并不易懂，但总体来说可读；本身的文档可以看作不错的PBR教学，其中会用到一些modern一点的工程实践，比如frame graph和job system，比如clustered forward的管线，比如ECS，比如它的material system也像模像样的，虽然这并不怎么好用  
还有比较出名的渲染器例如OGRE，但是稍微有点乱，历史包袱稍重，我的评价是不如看看Filament
>- 各平台上各位大师的无私分享 -- 比如鸭老师主导的[Sakura Engine](https://www.zhihu.com/column/c_1174428734253142016)，Maxwell的[VEngine](https://zhuanlan.zhihu.com/p/300650601)，文礼的[从零开始手敲次世代游戏引擎系列](https://zhuanlan.zhihu.com/p/28587092)，仕昶的[Scarlett](https://www.zhihu.com/column/c_1352653422265643008),Ubp.a的[RenderLab](https://github.com/Ubpa/RenderLab)，和Huanime的[MoonEngine](https://github.com/RIPmr/MoonEngine)等等许多，感谢各位老师的开源及分享，受益良多

当然，更知名的Unreal、CryEngine和Godot这类源码在此不做赘述，但是以博主的水平并不推荐从啃大型商业引擎的源码开始，因为太过复杂，体量太大，导致很可能无从下手，正反馈不足而丧失对学习游戏引擎的信心

### 游戏引擎架构
在诸多参考中，许多会以一张内容复杂的图来展示游戏引擎架构的概览（GAMES104、《游戏引擎架构》等都有这部分），其中关于引擎的架构，自下而上比较统一的部分会有：  
> 1. 平台层：如果是一个跨平台的游戏引擎，那么其中一个重要的工作就是处理不同平台的差异，抽象成统一的接口在上层调用，这样我们在开发其他所有的功能时可以忽略平台差异，这其中工作量最大的可能是抽象和封装RHI(Rendering Hardware Interface，这个叫法来自Unreal Engine)这一个工作，也就是处理不同平台所用渲染API的差异，其余需要做的还包括窗口、音频接口、IO等等
> 2. 核心层：这一层是在提供一些引擎开发中会用到的底层轮子，这一部分对代码质量要求很高，写完之后基本不太会动，比如数学库 / 内存管理 / 数据结构和容器的轮子（弃用C++ STL中提供的容器，自己实现对项目而言更好的轮子）等，一般是技术强者在写，比如我们熟知的John Carmack在Quake3中的快速平方根实现就会出现在这一层
> 3. 资源层：将各种格式的文件（模型、贴图、音频等）转化为引擎使用的资产，以及对各资产进行关联，管理资产的生命周期  


以上几个分层是引擎的地基，或者说比较通用的部分，在此之上，游戏引擎会有实质性的功能分层，但是这些功能分层在不同的参考资料中有不同的实现，笔者暂且通过自己的理解对Novl Engine最开始的架构进行继续分层：
> 4. 功能层：这一层可能是我们第一印象中“游戏引擎”会包含的内容，在之前分层的基础上，实现诸如物理/动画/渲染/3C/脚本/AI

 

## 1. 构建工程
构建工程并搭建起hello world通常是我们开展一个项目的第一步，在这个C++项目中，我并不会直接在VS中新建一个项目，把构建系统交给MSBuild，虽然工程的开发基本在Windows上，但博主仍然希望留有跨平台的扩展性，所以决定使用跨平台构建系统来构建这个项目  
**CMake**确实是C++工程的标准答案，博主在工作中也是使用CMake + Ninja作为C++部分的构建系统，然而CMake用起来还是感觉不太顺手，它的DSL写起来也不舒服，博主参考麦老师[这篇文章](https://zhuanlan.zhihu.com/p/492035106)，决定把构建系统交给好评如潮的**Xmake**  

Xmake的优势和使用不多赘述，可以看官方文档或知乎上的一些教程，直接开始构建我们的项目

~~~lua

~~~